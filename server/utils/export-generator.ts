import * as XLSX from 'xlsx';
import { Tool, ReportType, ToolTag } from '../../shared/schema.js';

interface ExportData {
    tools: Tool[];
    reportType: ReportType;
    tags: ToolTag[];
    startDate?: string;
    endDate?: string;
    generatedBy: string;
    generatedAt: Date;
}

export function generateCSV(data: ExportData): string {
    const { tools, tags } = data;

    // Filter tools based on tags if specified
    const filteredTools = tags.length > 0
        ? tools.filter(tool => tags.includes(tool.status as ToolTag))
        : tools;

    // Create CSV headers
    const headers = [
        'Tool ID',
        'Name',
        'Category',
        'Status',
        'Status Description',
        'Location',
        'Description',
        'Last Updated'
    ];

    // Create CSV rows with enhanced status information
    const rows = filteredTools.map(tool => [
        tool.tool_id,
        tool.name,
        tool.category,
        tool.status.toUpperCase(),
        getStatusLabel(tool.status),
        tool.location || '',
        tool.description || '',
        new Date(tool.last_updated).toLocaleDateString()
    ]);

    // Combine headers and rows
    const csvData = [headers, ...rows];

    // Convert to CSV string
    return csvData.map(row =>
        row.map(cell => `"${ cell }"`).join(',')
    ).join('\n');
}

export function generateExcel(data: ExportData): Buffer {
    const { tools, tags, reportType, generatedBy, generatedAt } = data;

    // Filter tools based on tags if specified
    const filteredTools = tags.length > 0
        ? tools.filter(tool => tags.includes(tool.status as ToolTag))
        : tools;

    // Create workbook
    const wb = XLSX.utils.book_new();

    // Create summary worksheet
    const summaryData = [
        ['Wireline Inventory Report'],
        [''],
        ['Report Type:', getReportTypeLabel(reportType)],
        ['Generated By:', generatedBy],
        ['Generated On:', generatedAt.toLocaleDateString()],
        ['Status Filter:', tags.length > 0 ? tags.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ') : 'All Statuses'],
        ['Total Tools:', filteredTools.length],
        [''],
        ['Status Summary:'],
        ['Red (Critical):', filteredTools.filter(t => t.status === 'red').length],
        ['Yellow (Warning):', filteredTools.filter(t => t.status === 'yellow').length],
        ['Green (Good):', filteredTools.filter(t => t.status === 'green').length],
        ['White (Inactive):', filteredTools.filter(t => t.status === 'white').length],
    ];

    const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');

    // Create tools data worksheet with enhanced status formatting
    const toolsData = [
        ['Tool ID', 'Name', 'Category', 'Status', 'Location', 'Description', 'Last Updated'],
        ...filteredTools.map(tool => [
            tool.tool_id,
            tool.name,
            tool.category,
            `${tool.status.toUpperCase()} - ${getStatusLabel(tool.status)}`, // Enhanced status display
            tool.location || '',
            tool.description || '',
            new Date(tool.last_updated).toLocaleDateString()
        ])
    ];

    const toolsWs = XLSX.utils.aoa_to_sheet(toolsData);
    
    // Apply styling to the tools worksheet
    const range = XLSX.utils.decode_range(toolsWs['!ref'] || 'A1');
    
    // Style header row
    for (let col = range.s.c; col <= range.e.c; col++) {
        const headerCell = XLSX.utils.encode_cell({ r: 0, c: col });
        if (!toolsWs[headerCell]) continue;
        
        toolsWs[headerCell].s = {
            font: { bold: true, color: { rgb: "FFFFFF" } },
            fill: { fgColor: { rgb: "4F46E5" } },
            alignment: { horizontal: "center" }
        };
    }
    
    // Style status column (column D, index 3) with colors based on status
    for (let row = 1; row <= range.e.r; row++) {
        const statusCell = XLSX.utils.encode_cell({ r: row, c: 3 }); // Status column
        if (!toolsWs[statusCell]) continue;
        
        const toolIndex = row - 1;
        if (toolIndex < filteredTools.length) {
            const status = filteredTools[toolIndex].status;
            let fillColor = "FFFFFF"; // Default white
            let fontColor = "000000"; // Default black
            
            switch (status) {
                case 'red':
                    fillColor = "FEE2E2"; // Light red background
                    fontColor = "DC2626"; // Red text
                    break;
                case 'yellow':
                    fillColor = "FEF3C7"; // Light yellow background
                    fontColor = "D97706"; // Orange text
                    break;
                case 'green':
                    fillColor = "D1FAE5"; // Light green background
                    fontColor = "059669"; // Green text
                    break;
                case 'white':
                    fillColor = "F3F4F6"; // Light gray background
                    fontColor = "6B7280"; // Gray text
                    break;
            }
            
            toolsWs[statusCell].s = {
                fill: { fgColor: { rgb: fillColor } },
                font: { color: { rgb: fontColor }, bold: true },
                alignment: { horizontal: "center" }
            };
        }
    }
    
    // Set column widths
    toolsWs['!cols'] = [
        { width: 12 }, // Tool ID
        { width: 25 }, // Name
        { width: 15 }, // Category
        { width: 20 }, // Status
        { width: 15 }, // Location
        { width: 30 }, // Description
        { width: 12 }  // Last Updated
    ];
    
    XLSX.utils.book_append_sheet(wb, toolsWs, 'Tools Data');

    // Generate buffer
    return XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
}

// Helper function to get status labels
function getStatusLabel(status: string): string {
    switch (status) {
        case 'red':
            return 'Critical';
        case 'yellow':
            return 'Warning';
        case 'green':
            return 'Good';
        case 'white':
            return 'Inactive';
        default:
            return 'Unknown';
    }
}

function getReportTypeLabel(reportType: ReportType): string {
    switch (reportType) {
        case 'tag-status':
            return 'Tag Status Report';
        case 'maintenance':
            return 'Maintenance Report';
        case 'inventory':
            return 'Inventory Summary';
        default:
            return 'General Report';
    }
}
