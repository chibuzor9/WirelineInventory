var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/utils/export-generator.ts
var export_generator_exports = {};
__export(export_generator_exports, {
  generateCSV: () => generateCSV,
  generateExcel: () => generateExcel
});
import * as XLSX from "xlsx";
function generateCSV(data) {
  const { tools: tools2, tags } = data;
  const filteredTools = tags.length > 0 ? tools2.filter((tool) => tags.includes(tool.status)) : tools2;
  const headers = [
    "Tool ID",
    "Name",
    "Category",
    "Status",
    "Location",
    "Description",
    "Last Updated"
  ];
  const rows = filteredTools.map((tool) => [
    tool.toolId,
    tool.name,
    tool.category,
    tool.status,
    tool.location || "",
    tool.description || "",
    new Date(tool.lastUpdated).toLocaleDateString()
  ]);
  const csvData = [headers, ...rows];
  return csvData.map(
    (row) => row.map((cell) => `"${cell}"`).join(",")
  ).join("\n");
}
function generateExcel(data) {
  const { tools: tools2, tags, reportType, generatedBy, generatedAt } = data;
  const filteredTools = tags.length > 0 ? tools2.filter((tool) => tags.includes(tool.status)) : tools2;
  const wb = XLSX.utils.book_new();
  const summaryData = [
    ["Wireline Inventory Report"],
    [""],
    ["Report Type:", getReportTypeLabel(reportType)],
    ["Generated By:", generatedBy],
    ["Generated On:", generatedAt.toLocaleDateString()],
    ["Status Filter:", tags.length > 0 ? tags.map((t) => t.charAt(0).toUpperCase() + t.slice(1)).join(", ") : "All Statuses"],
    ["Total Tools:", filteredTools.length],
    [""],
    ["Status Summary:"],
    ["Red (Critical):", filteredTools.filter((t) => t.status === "red").length],
    ["Yellow (Warning):", filteredTools.filter((t) => t.status === "yellow").length],
    ["Green (Good):", filteredTools.filter((t) => t.status === "green").length],
    ["White (Inactive):", filteredTools.filter((t) => t.status === "white").length]
  ];
  const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
  XLSX.utils.book_append_sheet(wb, summaryWs, "Summary");
  const toolsData = [
    ["Tool ID", "Name", "Category", "Status", "Location", "Description", "Last Updated"],
    ...filteredTools.map((tool) => [
      tool.toolId,
      tool.name,
      tool.category,
      tool.status,
      tool.location || "",
      tool.description || "",
      new Date(tool.lastUpdated).toLocaleDateString()
    ])
  ];
  const toolsWs = XLSX.utils.aoa_to_sheet(toolsData);
  XLSX.utils.book_append_sheet(wb, toolsWs, "Tools Data");
  return XLSX.write(wb, { type: "buffer", bookType: "xlsx" });
}
function getReportTypeLabel(reportType) {
  switch (reportType) {
    case "tag-status":
      return "Tag Status Report";
    case "maintenance":
      return "Maintenance Report";
    case "inventory":
      return "Inventory Summary";
    default:
      return "General Report";
  }
}
var init_export_generator = __esm({
  "server/utils/export-generator.ts"() {
    "use strict";
  }
});

// server/utils/pdf-generator.ts
var pdf_generator_exports = {};
__export(pdf_generator_exports, {
  generateReportPDF: () => generateReportPDF
});
import puppeteer from "puppeteer";
async function generateReportPDF(data) {
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"]
  });
  try {
    const page = await browser.newPage();
    await page.setViewport({ width: 1200, height: 800 });
    const html = generateReportHTML(data);
    await page.setContent(html, { waitUntil: "networkidle0" });
    const pdf = await page.pdf({
      format: "A4",
      printBackground: true,
      margin: {
        top: "20mm",
        right: "20mm",
        bottom: "20mm",
        left: "20mm"
      },
      displayHeaderFooter: true,
      headerTemplate: `
                <div style="font-size: 10px; color: #666; width: 100%; text-align: center; margin: 0 20px;">
                    <span>Wireline Inventory Report - ${data.reportType}</span>
                </div>
            `,
      footerTemplate: `
                <div style="font-size: 10px; color: #666; width: 100%; text-align: center; margin: 0 20px;">
                    <span>Page <span class="pageNumber"></span> of <span class="totalPages"></span> | Generated on ${data.generatedAt.toLocaleDateString()}</span>
                </div>
            `
    });
    return pdf;
  } finally {
    await browser.close();
  }
}
function generateReportHTML(data) {
  const { tools: tools2, reportType, tags, startDate, endDate, generatedBy, generatedAt } = data;
  const filteredTools = tags.length > 0 ? tools2.filter((tool) => tags.includes(tool.status)) : tools2;
  const statusCounts = {
    red: filteredTools.filter((t) => t.status === "red").length,
    yellow: filteredTools.filter((t) => t.status === "yellow").length,
    green: filteredTools.filter((t) => t.status === "green").length,
    white: filteredTools.filter((t) => t.status === "white").length
  };
  return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Wireline Inventory Report</title>
            <style>
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
                
                body {
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    line-height: 1.4;
                    color: #333;
                    background: #fff;
                }
                
                .report-header {
                    text-align: center;
                    margin-bottom: 30px;
                    padding-bottom: 20px;
                    border-bottom: 2px solid #e5e7eb;
                }
                
                .report-title {
                    font-size: 24px;
                    font-weight: bold;
                    color: #1f2937;
                    margin-bottom: 8px;
                }
                
                .report-subtitle {
                    font-size: 14px;
                    color: #6b7280;
                    margin-bottom: 4px;
                }
                
                .report-meta {
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 20px;
                    margin-bottom: 30px;
                    font-size: 12px;
                }
                
                .meta-section {
                    background: #f9fafb;
                    padding: 15px;
                    border-radius: 8px;
                    border: 1px solid #e5e7eb;
                }
                
                .meta-title {
                    font-weight: bold;
                    margin-bottom: 8px;
                    color: #374151;
                }
                
                .status-summary {
                    display: grid;
                    grid-template-columns: repeat(4, 1fr);
                    gap: 15px;
                    margin-bottom: 30px;
                }
                
                .status-card {
                    text-align: center;
                    padding: 15px;
                    border-radius: 8px;
                    border: 2px solid;
                }
                
                .status-red {
                    border-color: #dc2626;
                    background: rgba(220, 38, 38, 0.1);
                }
                
                .status-yellow {
                    border-color: #d97706;
                    background: rgba(217, 119, 6, 0.1);
                }
                
                .status-green {
                    border-color: #059669;
                    background: rgba(5, 150, 105, 0.1);
                }
                
                .status-white {
                    border-color: #6b7280;
                    background: rgba(107, 114, 128, 0.1);
                }
                
                .status-count {
                    font-size: 20px;
                    font-weight: bold;
                    margin-bottom: 4px;
                }
                
                .status-label {
                    font-size: 12px;
                    text-transform: uppercase;
                    font-weight: 500;
                }
                
                .tools-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-top: 20px;
                    font-size: 11px;
                }
                
                .tools-table th,
                .tools-table td {
                    border: 1px solid #e5e7eb;
                    padding: 8px;
                    text-align: left;
                }
                
                .tools-table th {
                    background: #f3f4f6;
                    font-weight: 600;
                    color: #374151;
                }
                
                .tools-table tr:nth-child(even) {
                    background: #f9fafb;
                }
                
                .status-badge {
                    display: inline-flex;
                    align-items: center;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 10px;
                    font-weight: 500;
                    text-transform: uppercase;
                }
                
                .badge-red {
                    background: rgba(220, 38, 38, 0.1);
                    color: #dc2626;
                    border: 1px solid #dc2626;
                }
                
                .badge-yellow {
                    background: rgba(217, 119, 6, 0.1);
                    color: #d97706;
                    border: 1px solid #d97706;
                }
                
                .badge-green {
                    background: rgba(5, 150, 105, 0.1);
                    color: #059669;
                    border: 1px solid #059669;
                }
                
                .badge-white {
                    background: rgba(107, 114, 128, 0.1);
                    color: #6b7280;
                    border: 1px solid #6b7280;
                }
                
                .status-dot {
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    display: inline-block;
                    margin-right: 6px;
                }
                
                .dot-red { background: #dc2626; }
                .dot-yellow { background: #d97706; }
                .dot-green { background: #059669; }
                .dot-white { background: #6b7280; }
                
                .page-break {
                    page-break-before: always;
                }
                
                @media print {
                    .tools-table {
                        page-break-inside: auto;
                    }
                    
                    .tools-table tr {
                        page-break-inside: avoid;
                        page-break-after: auto;
                    }
                }
            </style>
        </head>
        <body>
            <div class="report-header">
                <div class="report-title">Wireline Inventory Report</div>
                <div class="report-subtitle">${getReportTypeLabel2(reportType)}</div>
                <div class="report-subtitle">Generated by ${generatedBy} on ${generatedAt.toLocaleDateString()}</div>
            </div>
            
            <div class="report-meta">
                <div class="meta-section">
                    <div class="meta-title">Report Parameters</div>
                    <div><strong>Type:</strong> ${getReportTypeLabel2(reportType)}</div>
                    <div><strong>Status Filter:</strong> ${tags.length > 0 ? tags.map((t) => t.charAt(0).toUpperCase() + t.slice(1)).join(", ") : "All Statuses"}</div>
                    ${startDate ? `<div><strong>Date From:</strong> ${new Date(startDate).toLocaleDateString()}</div>` : ""}
                    ${endDate ? `<div><strong>Date To:</strong> ${new Date(endDate).toLocaleDateString()}</div>` : ""}
                </div>
                
                <div class="meta-section">
                    <div class="meta-title">Summary</div>
                    <div><strong>Total Tools:</strong> ${filteredTools.length}</div>
                    <div><strong>Categories:</strong> ${[...new Set(filteredTools.map((t) => t.category))].length}</div>
                    <div><strong>Locations:</strong> ${[...new Set(filteredTools.map((t) => t.location).filter(Boolean))].length}</div>
                </div>
            </div>
            
            <div class="status-summary">
                <div class="status-card status-red">
                    <div class="status-count">${statusCounts.red}</div>
                    <div class="status-label">Critical</div>
                </div>
                <div class="status-card status-yellow">
                    <div class="status-count">${statusCounts.yellow}</div>
                    <div class="status-label">Warning</div>
                </div>
                <div class="status-card status-green">
                    <div class="status-count">${statusCounts.green}</div>
                    <div class="status-label">Good</div>
                </div>
                <div class="status-card status-white">
                    <div class="status-count">${statusCounts.white}</div>
                    <div class="status-label">Inactive</div>
                </div>
            </div>
            
            <table class="tools-table">
                <thead>
                    <tr>
                        <th>Tool ID</th>
                        <th>Name</th>
                        <th>Category</th>
                        <th>Status</th>
                        <th>Location</th>
                        <th>Last Updated</th>
                        ${reportType === "tag-status" ? "<th>Description</th>" : ""}
                    </tr>
                </thead>
                <tbody>
                    ${filteredTools.map((tool) => `
                        <tr>
                            <td>${tool.toolId}</td>
                            <td>${tool.name}</td>
                            <td>${tool.category}</td>
                            <td>
                                <span class="status-badge badge-${tool.status}">
                                    <span class="status-dot dot-${tool.status}"></span>
                                    ${tool.status.charAt(0).toUpperCase() + tool.status.slice(1)}
                                </span>
                            </td>
                            <td>${tool.location || "N/A"}</td>
                            <td>${new Date(tool.lastUpdated).toLocaleDateString()}</td>
                            ${reportType === "tag-status" ? `<td>${tool.description || "N/A"}</td>` : ""}
                        </tr>
                    `).join("")}
                </tbody>
            </table>
        </body>
        </html>
    `;
}
function getReportTypeLabel2(reportType) {
  switch (reportType) {
    case "tag-status":
      return "Tag Status Report";
    case "maintenance":
      return "Maintenance Report";
    case "inventory":
      return "Inventory Summary";
    default:
      return "General Report";
  }
}
var init_pdf_generator = __esm({
  "server/utils/pdf-generator.ts"() {
    "use strict";
  }
});

// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/db.ts
import { createClient } from "@supabase/supabase-js";
import dotenv from "dotenv";
dotenv.config();
var supabaseUrl = process.env.SUPABASE_URL;
var supabaseKey = process.env.SUPABASE_KEY;
if (!supabaseUrl) {
  console.error("SUPABASE_URL environment variable is not defined");
  process.exit(1);
}
if (!supabaseKey) {
  console.error("SUPABASE_KEY environment variable is not defined");
  process.exit(1);
}
var supabase = createClient(supabaseUrl, supabaseKey);

// server/storage.ts
import session from "express-session";
import createMemoryStore from "memorystore";
import bcrypt from "bcryptjs";
var MemoryStore = createMemoryStore(session);
var SupabaseStorage = class {
  sessionStore;
  constructor() {
    this.sessionStore = new MemoryStore({ checkPeriod: 864e5 });
  }
  // User methods
  async getUser(id) {
    const { data, error } = await supabase.from("users").select("*").eq("id", id);
    if (error) {
      console.error("Error fetching user by id:", error);
      return void 0;
    }
    return data && data[0] ? data[0] : void 0;
  }
  async getUserByUsername(username) {
    const { data, error } = await supabase.from("users").select("*").eq("username", username);
    if (error) {
      console.error("Error fetching user by username:", error);
      return void 0;
    }
    return data && data[0] ? data[0] : void 0;
  }
  async createUser(user) {
    const hashedPassword = await bcrypt.hash(user.password, 10);
    const dbUser = {
      username: user.username,
      password: hashedPassword,
      full_name: user.full_name,
      email: user.email,
      role: "user"
    };
    const { data, error } = await supabase.from("users").insert([dbUser]).select().single();
    if (error || !data) {
      throw new Error(
        "Error creating user: " + (error?.message || "Unknown error")
      );
    }
    return data;
  }
  // Helper method to check if password is already hashed
  isPasswordHashed(password) {
    return /^\$2[aby]\$\d+\$/.test(password) && password.length === 60;
  }
  // Method to compare passwords (works with both hashed and plain text)
  async comparePassword(inputPassword, storedPassword) {
    if (this.isPasswordHashed(storedPassword)) {
      return await bcrypt.compare(inputPassword, storedPassword);
    }
    return inputPassword === storedPassword;
  }
  // Tool methods
  async getTool(id) {
    const { data, error } = await supabase.from("tools").select("*").eq("id", id);
    if (error) {
      console.error("Error fetching tool by id:", error);
      return void 0;
    }
    return data && data[0] ? data[0] : void 0;
  }
  async getToolByToolId(toolId) {
    const { data, error } = await supabase.from("tools").select("*").eq("toolId", toolId);
    if (error) {
      console.error("Error fetching tool by toolId:", error);
      return void 0;
    }
    return data && data[0] ? data[0] : void 0;
  }
  async getTools(options) {
    let query = supabase.from("tools").select("*", { count: "exact" });
    if (options?.status) query = query.eq("status", options.status);
    if (options?.category) query = query.eq("category", options.category);
    if (options?.search) query = query.ilike("name", `%${options.search}%`);
    if (options?.limit) query = query.limit(options.limit);
    if (options?.offset)
      query = query.range(
        options.offset,
        (options.offset || 0) + (options.limit || 10) - 1
      );
    const { data, error, count } = await query;
    if (error) {
      console.error("Error fetching tools:", error);
      return { tools: [], total: 0 };
    }
    return { tools: data || [], total: count || 0 };
  }
  async createTool(tool) {
    const { data, error } = await supabase.from("tools").insert([tool]).select().single();
    if (error || !data) {
      throw new Error(
        "Error creating tool: " + (error?.message || "Unknown error")
      );
    }
    return data;
  }
  async updateTool(id, tool) {
    const { data, error } = await supabase.from("tools").update(tool).eq("id", id).select().single();
    if (error) {
      console.error("Error updating tool:", error);
      return void 0;
    }
    return data;
  }
  async deleteTool(id) {
    const { error } = await supabase.from("tools").delete().eq("id", id);
    if (error) {
      console.error("Error deleting tool:", error);
      return false;
    }
    return true;
  }
  // Activity methods
  async createActivity(activity) {
    const { data, error } = await supabase.from("activities").insert([activity]).select().single();
    if (error || !data) {
      throw new Error(
        "Error creating activity: " + (error?.message || "Unknown error")
      );
    }
    return data;
  }
  async getActivities(limit = 10) {
    const { data: activitiesData, error: activitiesError } = await supabase.from("activities").select("*").order("timestamp", { ascending: false }).limit(limit);
    if (activitiesError) {
      console.error("Error fetching activities:", activitiesError);
      return [];
    }
    if (!activitiesData || activitiesData.length === 0) {
      return [];
    }
    const userIds = Array.from(
      new Set(activitiesData.map((a) => a.user_id).filter(Boolean))
    );
    const toolIds = Array.from(
      new Set(activitiesData.map((a) => a.tool_id).filter(Boolean))
    );
    const [usersResult, toolsResult] = await Promise.all([
      userIds.length > 0 ? supabase.from("users").select("id, username, full_name").in("id", userIds) : { data: [], error: null },
      toolIds.length > 0 ? supabase.from("tools").select("id, tool_id, name, status").in("id", toolIds) : { data: [], error: null }
    ]);
    const usersMap = new Map(usersResult.data?.map((u) => [u.id, u]) || []);
    const toolsMap = new Map(toolsResult.data?.map((t) => [t.id, t]) || []);
    const enrichedActivities = activitiesData.map((activity) => ({
      ...activity,
      user: activity.user_id ? usersMap.get(activity.user_id) : null,
      tool: activity.tool_id ? toolsMap.get(activity.tool_id) : null
    }));
    return enrichedActivities;
  }
  async getToolStats() {
    const { data, error } = await supabase.from("tools").select("status");
    if (error || !data) {
      console.error("Error fetching tool stats:", error);
      return { red: 0, yellow: 0, green: 0, white: 0 };
    }
    const stats = { red: 0, yellow: 0, green: 0, white: 0 };
    for (const tool of data) {
      if (tool.status === "red") stats.red++;
      if (tool.status === "yellow") stats.yellow++;
      if (tool.status === "green") stats.green++;
      if (tool.status === "white") stats.white++;
    }
    return stats;
  }
  async getToolsForReport(filters) {
    let query = supabase.from("tools").select("*");
    if (filters.tags && filters.tags.length > 0) {
      query = query.in("status", filters.tags);
    }
    if (filters.startDate) {
      query = query.gte("lastUpdated", filters.startDate);
    }
    if (filters.endDate) {
      query = query.lte("lastUpdated", filters.endDate);
    }
    const { data, error } = await query.order("toolId", { ascending: true });
    if (error) {
      throw new Error("Error fetching tools for report: " + error.message);
    }
    return data;
  }
  async getToolsByStatus(statuses) {
    const { data, error } = await supabase.from("tools").select("*").in("status", statuses).order("lastUpdated", { ascending: false });
    if (error) {
      throw new Error("Error fetching tools by status: " + error.message);
    }
    return data;
  }
};
var storage = new SupabaseStorage();

// server/auth.ts
import session2 from "express-session";
function setupAuth(app2) {
  const sessionSettings = {
    secret: process.env.SESSION_SECRET || "halliburton-inventory-secret",
    resave: false,
    saveUninitialized: false,
    cookie: {
      maxAge: 24 * 60 * 60 * 1e3
      // 24 hours
    }
  };
  app2.set("trust proxy", 1);
  app2.use(session2(sessionSettings));
}

// shared/schema.ts
import { pgTable, text, serial, integer, timestamp, foreignKey, bigint, varchar, smallint } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { relations } from "drizzle-orm";
var users = pgTable("users", {
  id: bigint("id", { mode: "bigint" }).primaryKey(),
  username: varchar("username").notNull().unique(),
  password: text("password").notNull(),
  full_name: text("full_name").notNull(),
  email: varchar("email").notNull(),
  role: varchar("role").default("user").notNull(),
  created_at: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  status: smallint("status").default(1)
});
var insertUserSchema = createInsertSchema(users).omit({
  id: true,
  created_at: true
});
var tools = pgTable("tools", {
  id: serial("id").primaryKey(),
  toolId: text("tool_id").notNull().unique(),
  name: text("name").notNull(),
  category: text("category").notNull(),
  description: text("description"),
  status: text("status").notNull(),
  // 'red', 'yellow', 'green'
  location: text("location"),
  lastUpdated: timestamp("last_updated").notNull(),
  lastUpdatedBy: bigint("last_updated_by", { mode: "bigint" }).notNull()
}, (table) => {
  return {
    lastUpdatedByFk: foreignKey({
      columns: [table.lastUpdatedBy],
      foreignColumns: [users.id]
    })
  };
});
var insertToolSchema = createInsertSchema(tools).omit({
  id: true,
  lastUpdatedBy: true,
  lastUpdated: true
});
var activities = pgTable("activities", {
  id: serial("id").primaryKey(),
  user_id: integer("user_id").notNull(),
  action: varchar("action", { length: 255 }).notNull(),
  toolId: integer("toolId"),
  timestamp: timestamp("timestamp").defaultNow(),
  details: text("details"),
  comments: text("comments"),
  previous_status: text("previous_status")
}, (table) => {
  return {
    userIdFk: foreignKey({
      columns: [table.user_id],
      foreignColumns: [users.id]
    }),
    toolIdFk: foreignKey({
      columns: [table.toolId],
      foreignColumns: [tools.id]
    })
  };
});
var insertActivitySchema = createInsertSchema(activities).omit({
  id: true
});
var usersRelations = relations(users, ({ many }) => ({
  tools: many(tools, { relationName: "user_tools" }),
  activities: many(activities, { relationName: "user_activities" })
}));
var toolsRelations = relations(tools, ({ one, many }) => ({
  updatedBy: one(users, {
    fields: [tools.lastUpdatedBy],
    references: [users.id],
    relationName: "user_tools"
  }),
  activities: many(activities, { relationName: "tool_activities" })
}));
var activitiesRelations = relations(activities, ({ one }) => ({
  user: one(users, {
    fields: [activities.user_id],
    references: [users.id],
    relationName: "user_activities"
  }),
  tool: one(tools, {
    fields: [activities.toolId],
    references: [tools.id],
    relationName: "tool_activities"
  })
}));
var toolTagSchema = z.enum(["red", "yellow", "green", "white"]);
var toolCategorySchema = z.enum([
  "Pressure Equipment",
  "Perforating Equipment",
  "Logging Equipment",
  "Wireline Equipment",
  "Completion Equipment",
  "Other"
]);
var reportTypeSchema = z.enum([
  "tag-status",
  "maintenance",
  "inventory",
  "activity"
]);

// server/routes.ts
import { z as z2 } from "zod";
async function getUserFromSession(req) {
  const userId = req.session?.userId;
  if (!userId) return null;
  const user = await storage.getUser(userId);
  return user || null;
}
function isAuthenticated(req) {
  return !!req.session?.userId;
}
function getNotificationType(action, details) {
  if (action === "create") return "success";
  if (action === "delete") return "error";
  if (action === "update" && details.includes("Red")) return "error";
  if (action === "update" && details.includes("Yellow")) return "warning";
  if (action === "update" && details.includes("Green")) return "success";
  if (action === "report") return "info";
  return "info";
}
function getNotificationTitle(action, details) {
  switch (action) {
    case "create":
      return "New Tool Added";
    case "update":
      if (details.includes("tag")) {
        return "Tool Status Changed";
      }
      return "Tool Updated";
    case "delete":
      return "Tool Removed";
    case "report":
      return "Report Generated";
    default:
      return "System Activity";
  }
}
async function registerRoutes(app2) {
  setupAuth(app2);
  app2.post(
    "/api/login",
    async (req, res, next) => {
      try {
        const { username, password } = req.body;
        console.log(`[LOGIN ATTEMPT] username: ${username}`);
        const user = await storage.getUserByUsername(username);
        if (!user) {
          console.log(
            `[LOGIN FAIL] username: ${username} (user not found)`
          );
          return res.status(401).send("Invalid username or password");
        }
        let isPasswordValid = false;
        if (user.role === "admin") {
          isPasswordValid = user.password === password;
        } else {
          isPasswordValid = await storage.comparePassword(
            password,
            user.password
          );
        }
        if (!isPasswordValid) {
          console.log(
            `[LOGIN FAIL] username: ${username} (wrong password)`
          );
          return res.status(401).send("Invalid username or password");
        }
        req.session.userId = Number(user.id);
        console.log(
          `[LOGIN SUCCESS] username: ${username}, id: ${Number(user.id)}`
        );
        res.json(user);
      } catch (error) {
        console.error(
          `[LOGIN ERROR] username: ${req.body?.username}`,
          error
        );
        next(error);
      }
    }
  );
  app2.post("/api/logout", (req, res) => {
    req.session.destroy(() => {
      res.status(200).json({ message: "Logged out" });
    });
  });
  app2.get(
    "/api/user",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const user = await getUserFromSession(req);
        if (!user) return res.sendStatus(401);
        res.json(user);
      } catch (error) {
        next(error);
      }
    }
  );
  app2.get(
    "/api/stats",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const stats = await storage.getToolStats();
        res.json(stats);
      } catch (error) {
        next(error);
      }
    }
  );
  app2.get(
    "/api/tools",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const status = req.query.status;
        const category = req.query.category;
        const search = req.query.search;
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        const offset = (page - 1) * limit;
        const result = await storage.getTools({
          status,
          category,
          search,
          limit,
          offset
        });
        res.json(result);
      } catch (error) {
        next(error);
      }
    }
  );
  app2.get(
    "/api/tools/:id",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const id = Number(req.params.id);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid ID format" });
        }
        const tool = await storage.getTool(id);
        if (!tool) {
          return res.status(404).json({ message: "Tool not found" });
        }
        res.json(tool);
      } catch (error) {
        next(error);
      }
    }
  );
  app2.post(
    "/api/tools",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const user = await getUserFromSession(req);
        if (!user) return res.sendStatus(401);
        if (user.role !== "admin") {
          return res.status(403).json({
            message: "Access denied. Admin role required to create tools."
          });
        }
        const validation = insertToolSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            message: "Invalid tool data",
            errors: validation.error.format()
          });
        }
        if (!toolTagSchema.safeParse(req.body.status).success) {
          return res.status(400).json({
            message: "Invalid tag status. Must be 'red', 'yellow', or 'green'"
          });
        }
        const toolData = {
          ...req.body,
          lastUpdated: /* @__PURE__ */ new Date(),
          lastUpdatedBy: Number(user.id)
        };
        const tool = await storage.createTool(toolData);
        await storage.createActivity({
          user_id: Number(user.id),
          action: "create",
          toolId: tool.id,
          timestamp: /* @__PURE__ */ new Date(),
          details: `Created tool ${tool.name} (${tool.toolId}) with ${tool.status} tag`
        });
        res.status(201).json(tool);
      } catch (error) {
        next(error);
      }
    }
  );
  app2.put(
    "/api/tools/:id",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const user = await getUserFromSession(req);
        if (!user) return res.sendStatus(401);
        const id = Number(req.params.id);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid ID format" });
        }
        const existingTool = await storage.getTool(id);
        if (!existingTool) {
          return res.status(404).json({ message: "Tool not found" });
        }
        if (req.body.status && req.body.status !== existingTool.status) {
          if (!toolTagSchema.safeParse(req.body.status).success) {
            return res.status(400).json({
              message: "Invalid tag status. Must be 'red', 'yellow', or 'green'"
            });
          }
        }
        const toolUpdate = {
          ...req.body,
          lastUpdated: /* @__PURE__ */ new Date(),
          lastUpdatedBy: Number(user.id)
        };
        const updatedTool = await storage.updateTool(id, toolUpdate);
        if (req.body.status && req.body.status !== existingTool.status) {
          await storage.createActivity({
            user_id: Number(user.id),
            action: "update",
            toolId: id,
            timestamp: /* @__PURE__ */ new Date(),
            details: `Changed tag for ${updatedTool?.name} (${updatedTool?.toolId}) from ${existingTool.status} to ${req.body.status}`,
            comments: req.body.comment || "",
            previous_status: existingTool.status
          });
        } else {
          await storage.createActivity({
            user_id: Number(user.id),
            action: "update",
            toolId: id,
            timestamp: /* @__PURE__ */ new Date(),
            details: `Updated tool ${updatedTool?.name} (${updatedTool?.toolId})`,
            comments: req.body.comment || "",
            previous_status: void 0
          });
        }
        res.json(updatedTool);
      } catch (error) {
        next(error);
      }
    }
  );
  app2.delete(
    "/api/tools/:id",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const user = await getUserFromSession(req);
        if (!user) return res.sendStatus(401);
        if (user.role !== "admin") {
          return res.status(403).json({
            message: "Access denied. Admin role required to delete tools."
          });
        }
        const id = Number(req.params.id);
        if (isNaN(id)) {
          return res.status(400).json({ message: "Invalid ID format" });
        }
        const tool = await storage.getTool(id);
        if (!tool) {
          return res.status(404).json({ message: "Tool not found" });
        }
        await storage.deleteTool(id);
        await storage.createActivity({
          user_id: Number(user.id),
          action: "delete",
          toolId: id,
          timestamp: /* @__PURE__ */ new Date(),
          details: `Deleted tool ${tool.name} (${tool.toolId})`
        });
        res.status(204).send();
      } catch (error) {
        next(error);
      }
    }
  );
  app2.get(
    "/api/activities",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const limit = req.query.limit ? parseInt(req.query.limit) : 10;
        const activities2 = await storage.getActivities(limit);
        const enrichedActivities = activities2.map((activity) => ({
          ...activity,
          timestamp: new Date(activity.timestamp).toISOString()
          // user and tool are already included from storage
        }));
        res.json(enrichedActivities);
      } catch (error) {
        console.error("Activities API error:", error);
        next(error);
      }
    }
  );
  app2.post(
    "/api/reports",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const reportTypeValidation = reportTypeSchema.safeParse(
          req.body.reportType
        );
        if (!reportTypeValidation.success) {
          return res.status(400).json({ message: "Invalid report type" });
        }
        const tagsValidation = z2.array(toolTagSchema).safeParse(req.body.tags);
        if (!tagsValidation.success) {
          return res.status(400).json({ message: "Invalid tag selection" });
        }
        const dateRangeSchema = z2.object({
          startDate: z2.string().optional(),
          endDate: z2.string().optional()
        });
        const dateRangeValidation = dateRangeSchema.safeParse({
          startDate: req.body.startDate,
          endDate: req.body.endDate
        });
        if (!dateRangeValidation.success) {
          return res.status(400).json({ message: "Invalid date range" });
        }
        const user = await getUserFromSession(req);
        if (!user) return res.sendStatus(401);
        const tools2 = await storage.getToolsForReport({
          tags: req.body.tags,
          startDate: req.body.startDate,
          endDate: req.body.endDate
        });
        const reportData = {
          tools: tools2,
          reportType: req.body.reportType,
          tags: req.body.tags,
          startDate: req.body.startDate,
          endDate: req.body.endDate,
          generatedBy: user.full_name || user.username,
          generatedAt: /* @__PURE__ */ new Date()
        };
        const format = req.body.format || "pdf";
        let buffer;
        let contentType;
        let fileName;
        switch (format) {
          case "csv": {
            const { generateCSV: generateCSV2 } = await Promise.resolve().then(() => (init_export_generator(), export_generator_exports));
            const csvContent = generateCSV2(reportData);
            buffer = Buffer.from(csvContent, "utf-8");
            contentType = "text/csv";
            fileName = `wireline-report-${req.body.reportType}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.csv`;
            break;
          }
          case "excel": {
            const { generateExcel: generateExcel2 } = await Promise.resolve().then(() => (init_export_generator(), export_generator_exports));
            buffer = generateExcel2(reportData);
            contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            fileName = `wireline-report-${req.body.reportType}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.xlsx`;
            break;
          }
          default: {
            const { generateReportPDF: generateReportPDF2 } = await Promise.resolve().then(() => (init_pdf_generator(), pdf_generator_exports));
            buffer = await generateReportPDF2(reportData);
            contentType = "application/pdf";
            fileName = `wireline-report-${req.body.reportType}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.pdf`;
            break;
          }
        }
        await storage.createActivity({
          user_id: Number(user.id),
          action: "report",
          timestamp: /* @__PURE__ */ new Date(),
          details: `Generated ${req.body.reportType} report (${format.toUpperCase()}) for ${req.body.tags.join(", ") || "all"} tagged tools`
        });
        res.setHeader("Content-Type", contentType);
        res.setHeader("Content-Disposition", `attachment; filename="${fileName}"`);
        res.setHeader("Content-Length", buffer.length);
        res.send(buffer);
      } catch (error) {
        console.error("Report generation error:", error);
        next(error);
      }
    }
  );
  app2.post("/api/register", async (req, res, next) => {
    try {
      const { username, password, full_name, email } = req.body;
      if (!username || !password || !full_name || !email) {
        return res.status(400).json({ message: "All fields are required" });
      }
      console.log("[REGISTER] Received data:", {
        username,
        full_name,
        email,
        hasPassword: !!password
      });
      const existing = await storage.getUserByUsername(username);
      if (existing) {
        return res.status(409).json({ message: "Username already exists" });
      }
      const validatedData = insertUserSchema.parse({
        username,
        password,
        full_name,
        email,
        role: "user"
      });
      const userData = {
        username: validatedData.username,
        password: validatedData.password,
        full_name: validatedData.full_name,
        email: validatedData.email,
        role: validatedData.role
      };
      const user = await storage.createUser(userData);
      req.session.userId = Number(user.id);
      res.status(201).json(user);
    } catch (error) {
      next(error);
    }
  });
  app2.get(
    "/api/notifications",
    async (req, res, next) => {
      try {
        if (!isAuthenticated(req)) return res.sendStatus(401);
        const user = await getUserFromSession(req);
        if (!user) return res.sendStatus(401);
        const activities2 = await storage.getActivities(20);
        const alertTools = await storage.getToolsByStatus(["red", "yellow"]);
        const activityNotifications = activities2.map((activity, index) => ({
          id: `activity-${activity.id}`,
          type: getNotificationType(activity.action, activity.details),
          title: getNotificationTitle(activity.action, activity.details),
          message: activity.details || `${activity.action} performed`,
          timestamp: activity.timestamp,
          read: false,
          source: "activity",
          data: activity
        }));
        const toolNotifications = alertTools.slice(0, 5).map((tool) => ({
          id: `tool-${tool.id}`,
          type: tool.status === "red" ? "error" : "warning",
          title: `Tool Attention Required`,
          message: `${tool.name} (${tool.toolId}) has ${tool.status} status and may need attention`,
          timestamp: tool.lastUpdated,
          read: false,
          source: "tool",
          data: tool
        }));
        const allNotifications = [...activityNotifications, ...toolNotifications].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).slice(0, 15);
        res.json(allNotifications);
      } catch (error) {
        console.error("Notifications API error:", error);
        next(error);
      }
    }
  );
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin()
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  envDir: path.resolve(import.meta.dirname),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    proxy: {
      "/api": "http://localhost:5000"
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
function serveStatic(app2) {
  let distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    distPath = path2.resolve(import.meta.dirname, "..", "dist", "public");
  }
  if (!fs.existsSync(distPath)) {
    distPath = path2.resolve(process.cwd(), "dist", "public");
  }
  if (!fs.existsSync(distPath)) {
    console.error(`Could not find the build directory. Tried:
        - ${path2.resolve(import.meta.dirname, "public")}
        - ${path2.resolve(import.meta.dirname, "..", "dist", "public")}
        - ${path2.resolve(process.cwd(), "dist", "public")}`);
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  console.log(`Serving static files from: ${distPath}`);
  app2.use(express.static(distPath));
}
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: ["localhost", "127.0.0.1"]
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("/*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}

// server/index.ts
import "dotenv/config";
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  const isDevelopment = app.get("env") === "development" || process.env.NODE_ENV === "development";
  console.log(`Environment: ${app.get("env")}`);
  console.log(`NODE_ENV: ${process.env.NODE_ENV}`);
  console.log(`Is Development: ${isDevelopment}`);
  console.log(`Current directory: ${process.cwd()}`);
  console.log(`__dirname equivalent: ${import.meta.dirname}`);
  if (isDevelopment) {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();
